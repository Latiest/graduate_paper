\chapter{基于改进的K-Shape时间序列聚类算法的气井分类算法}
在气井开采初期，气井一经投入使用就会打破气藏的静态平衡，诸如产量、压力和产物性质等关键参数便会随之变动。随着开采活动的进行，气水关系会愈加错综复杂。产水量将持续攀升，
低压井和产水井的数量不断增长，不同气井之间的差异会日益增大。这些因素会进一步增加气井的生产管理难度。为提高管理效能，企业需利用历史产量数据对气井进行有效分类。将
表现出相似生产特性的气井进行归类和分析，以帮助揭示它们的共同生产模式。使得企业能够迅速评估气井的生产状况，掌握关键生产特征，进而及时规划出针对性强的管理策略和治
理行动，以确保气井的顺畅运作。本章根据基于改进的分数阶时间序列聚类算法，根据气井的历史产量数据，对气井进行分类。首先对企业提供的报表数据进行整理和清洗，去除掉
报表中的冗余数据并将需要的信息批量提取出来。在获取了产量相关的序列后，使用改进的K-Shape时间序列聚类算法来对气井进行分类。
\section{问题分析}
企业气田的地质条件十分复杂，是典型的“低渗透、低压力、低丰度”气田。其单井产量小、压降速率快，随着气田不断进行规模开发，单井井数逐年增加，集气站也在不断的增大。
随着开采活动的不断进行，间歇井（气井按照固定的开关制度进行生产的气井）数量的也在逐步递增。气井在开采过程中，产量会随着井底污染、地层压力、地层渗透率、地层有效厚度
等的变化。不同气井产量随时间的变化差异巨大。因此，通过对气井产量进行时间序列聚类，可以将历史产量特性相似的井分为一类进行管理。帮助企业在后续开采、产气量预测
以及对间歇井的开关井策略制定时，根据类别分别制定方案。基于此需求，本章采用改进的K-Shape时间序列聚类算法，通过SBD来度量两变量之间的相似性，再根据数据的特征指定
初始簇心，通过迭代的方式不断更新，最终得到气井分类的结果。
\section{问题描述}
在气井产量的时间序列聚类分析中，我们的目标是将历史产量数据分组，以揭示不同气井的生产行为和潜在模式。具体而言，每个气井的时间序列数据可以表示为 \( X_i = \{x_{i1}, x_{i2}, \ldots, x_{im}\} \)，其中 \( m \) 代表了时间序列的长度，即观测周期的总数。我们有 \( N \) 个这样的时间序列，形成了一个时间序列集合 \( X = \{x_1, x_2, \ldots, x_N\} \)，我们的目标是将这些序列聚类到 \( k \) 个不同的类别中。
在聚类分析中，每个类别可能代表着不同的气井种类，正处在高产期和衰退期的井之间的时间序列差异巨大。假设k=3（但实际应用中需要根据肘部法则来确定最优的k值）则种类可以预先定义为类别 \( Y = \{0,1,2\} \)。因此，我们的任务是定义一个映射函数 \( f: X \to Y \)，它可以将每个时间序列分配到这些预定义的类别中。
\section{基于改进的K-Shape时间序列聚类算法的气井分类算法}
\subsection{算法流程}
在传统的K-Shape聚类算法中，初始参考中心的选择是通过从样本集中随机挑选k个样本来进行的。这种随机选择方法可能会导致算法收敛于次优解，且每次运行结果都不一致，导致聚类结果不稳定。尤其是当数据集包含噪声或者离群点时。随机选取的初始中心可能不代表数据的真实结构，导致最终的聚类结果缺乏可解释性和准确性。此外，当样本集规模庞大时，随机选择方法可能导致算法收敛速度缓慢，影响聚类效率。
为了确定合适的聚类，通常采用多次实验的方法。本文结合领域知识和数据特点给出了一种改进策略：即根据数据特征选取初始中心点。具体如下：根据气井的历年累计产量，平均产量，
峰值产量的统计结果，对气井进行排序，并将其划分为k个区间，在每个区间内抽取中间的气井作为初始中心点。这样的方式可以使得初始的中心点更符合数据分布，从而实现
提高算法运行的稳定性。算法的流程图如图\ref{fig:K-Shape}所示。
\begin{figure}
    \centering
    % Requires \usepackage{graphicx}
    \includegraphics[scale=0.15,angle=0]{figure/K-Shape.jpg}\\
    \caption{基于改进的K-Shape时间序列聚类算法的气井分类算法流程图}
    \label{fig:K-Shape}
\end{figure}
初始报表的数据复杂且混乱，需要我们对其进行数据清理和整理，以形成一张规范的报表。在此基础上可以获取完整的产量数据，我们再根据第2章的方法对其进行归一化处理。然后
通过上文的方式选取初始参考中心。接下来，我们将通过不断的迭代更新簇心的方式来寻找最终的气井分类结果。这个过程将一直持续，直到簇心不再发生变化或者达到了预设
的最大迭代次数。最终，我们将得到一个高质量的气井分类结果。
\subsection{数据处理}
由于接下来需要进行气井产量预测，因此本章将所有需要用到的气井数据进行统一处理，而不仅仅只处理产量数据。原始数据集为单井日报文件，所给原始数据集时间跨度为：2012年8月3日至2022年8月15日，储存格式为一月的数据储存在一张excel多表中，一年共12张多表，每个
多表包含一月的数据，其中每日数据记录在一张excel表中，表中包含信息有所属井丛，井号，配产，生产时间(日累，月累，其中月累从2014年4月引入)，油压，
套压(从2016年9月起开始引入)，井口温度，注醇量(以井丛为单位)，产气量(日产，月累，年累，历年年累)，投产日期，备注(开关井信息)等。为进行批量读取处
理，需要先按照数据格式对所有报表进行划分，划分需考虑的因素包括不同的表头，报表的不同组织形式，不同的日期记录格式，剔除不需要的表（如一些影响批量读取的
总结性信息。如2012年的数据格式记录较为混乱，8，9两月的单井日报单井记录为了一个excel文件，10月，11月，12月三个月份的数据，由3个excel包含了各自月份的数据。
如图\ref{fig:difTable}展示了不同的表头、日期记录格式和表中的总结性表。
\begin{figure}
    \centering
    \includegraphics[scale=0.3,angle=0]{figure/表头1.png}
    \hfil
    \includegraphics[scale=0.3,angle=0]{figure/表头2.png}
    \hfil
    \includegraphics[scale=0.25,angle=0]{figure/表头3.png}
    \hfil
    \includegraphics[scale=0.3,angle=0]{figure/日期格式1.png}
    \hfil
    \includegraphics[scale=0.3,angle=0]{figure/日期格式2.png}
    \hfil
    \includegraphics[scale=0.3,angle=0]{figure/总结性表.png}
    \caption{不同的表头、日期格式及总结性表}
    \label{fig:difTable}
\end{figure}

对原始数据进行初步分析，需要的列包括日期，集气站号，井序号，日产时间，井口压力(油压)，套压，井口温度，日产量，投产时间，其中套压数据从2016年9月开始。

批量读取原始数据，去除每张表中原始数据中的冗余信息，并提取出相关的列，得到所有的单井日报数据表，每张表存储在一个csv格式的文件中。每日的单井日报数据可
以看作一个数据集，为合并多数据集为一个单数据集，需对所有的单井日报数据进行一致化处理，具体步骤如下：对需要的列的空值进行填充；数据格式转换，所有单日数据
统一转换为csv格式，时间跨度为2012年8月3日至2022年8月15日，共计生成约3664个csv文件。生成所有的单数据集后，需先对所有的数据进行数据合并以生成一个完整
数据集，这个完整数据集中包含了所有气井所有时间的数据，存储在一个csv文件中，文件名为GasProductionOri.csv。然后进行单数据集的数据清洗过程，具体步骤
为，选择合适的子列，并对列进行重新命名，数据集按时间顺序排列，如图\ref{fig:afterprocess}所示。下一步进行数据类型统一化，即处理格式错误，需要处理的项包括，对日期数据的标准
化，即将日期格式的数据统一转换为一定的格式，如’2022-08-15’，然后转换为标准的时间戳格式，浮点数类型的标准化，将字符串记录的数值统一转换为浮点型；然后处
理记录错误或异常值的情况，数据集中存在的异常情况是生产时间和日产量不匹配的问题，具体来说，存在部分记录日产量记录为0.0008，但日开井时间却为24小时，因此
需要将这部分数据的日开井时间修正为0。最后，检验数据集中存在的重复值，进行去重处理，得到训练时间序列模型所需要的完整数据集。
\begin{figure}
    \centering
    \includegraphics{figure/afterprocessdata.png}
    \caption{进行处理后的数据集示意图}
    \label{fig:afterprocess}
\end{figure}

剔除生产日期小于60天的井后，对其余井的历年累积产量，平均产量，峰值产量的进行统计分析，统计项包括计数，平均值，标准差，最小值，25\%分位数，中位数数，
75\%分位数，最大值，结果如下表所示，共910项数据。

\begin{figure}
    \centering
    \includegraphics{figure/gasproduction.png}
    \caption{历年累积产量，平均产量，峰值产量的统计结果}
\end{figure}

为方便查看每口井产气量随时间的变化趋势，以及井与井之间的时间序列曲线是否不相交，对所有井的产量随时间的变化曲线进行绘制，所绘制折线图为交互式的，可以选择需要查看的井，以及检查曲线处单点的值。
\begin{figure}
    \centering
    \includegraphics[scale=0.3,angle=0]{figure/productiongraph.png}
    \caption{在一张图上同时绘制多口井产量随时间的变化曲线}
    \label{fig:productionchange}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[scale=0.3,angle=0]{figure/awellgraph.png}
    \caption{井SN0004-04的产量随时间的变化曲线}
\end{figure}
\subsection{计算SBD距离}
由章节\ref{section2.1.1}可得，要计算SBD距离，需要先计算两条时间序列$x_t,y_t$之间的互相关$CC_w$,对互相关归一化得到$NCC_c$,根据最大的$NCC_c$计算两条序列
之间的SBD距离。再通过$NCC_c$取最大值（即$CC_w$值最大）时的w值减去$y_t$的长度来确定$y_t$与$x_t$最匹配时应该移动的步数。其算法如算法\ref{al:SBD}所示：
\begin{algorithm}[H]
    \caption{计算SBD距离以及与$y_t$对齐后的序列$\hat{y}_t$:$(\text{distance}, \hat{y}_t) = SBD(x_t, y_t)$}
    \begin{algorithmic}[1]
        \Require 两个归一化后的序列$x_t,y_t$
        \Ensure SBD距离dist，与$x_t$对齐后的序列$\hat{y}_t$
        \State 计算互相关值$CC_w(x_t, y_t) = F^{-1}(F(x_t) \times F(y_t))$\Comment{公式\eqref{eq:ccf}}%\eqref{eq:ccf}
        \State 对互相关值进行系数归一化$NCC_c = \frac{CC_w(x,y)}{\|x\|\|y\|}$
        \State $SBD(x_t, y_t) = 1 - \max_w \left( \frac{CC_w(x_t, y_t)}{\|x_t\| \cdot \|y_t\|} \right)$\Comment{公式\eqref{eq:SBD}}
        \State 计算$x_t,y_t$的长度$l_{y} = \text{length}(y_{t}),\text{length}(y_{t})$
        \State $y_t$的移动步数shift为$s = \text{which.max}(NCC) - l_y$
        \If{$s \geq 0$}:
            \State $\hat{y}_t = [\text{zeros}(0,s),y(1:l_x - s)]$\Comment{公式\eqref{eq:shift}}
        \Else:
            \State $\hat{y}_t = [y(1 - s:l_y),\text{zeros}(1,l_x - l_y - s)]$\Comment{公式\eqref{eq:shift}}
        \EndIf
    \end{algorithmic}
    \label{al:SBD}
\end{algorithm}  
\subsection{基于SBD距离的簇心提取}
根据章节\ref{section2.1.1}的介绍，求簇心需要得到$\mathbf{S} = \sum_{x_t \in P_k} x_t \cdot x_t^T$的最大特征值，此时$\mathbf{S}$最大特征值
对应的特征向量就是簇心对应的矩阵。其算法如算法\ref{al:center}所示：
\begin{algorithm}
    \caption{根据当前簇心\mathbf{C}和所有点\mathbf{S},计算更合理的簇心\hat{\mathbf{C}}:$\mathbf{\hat{C}} = \text{SE}(\mathbf{C},\mathbf{X})$}
\end{algorithm}